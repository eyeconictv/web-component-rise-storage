<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">

<script src="../underscore/underscore.js"></script>

<polymer-element name="rise-storage" attributes="companyId folder fileName fileType contentType refresh sort sortDirection">
  <template>
    <core-ajax id="storage"
      url="{{storageUrl}}"
      handleAs="json"
      on-core-response="{{handleStorageResponse}}"
      on-core-error="{{handleStorageError}}">
    </core-ajax>

    <core-ajax id="cache"
      url="{{cacheUrl}}"
      handleAs="blob"
      on-core-response="{{handleCacheResponse}}"
      on-core-error="{{handleCacheError}}">
    </core-ajax>

    <core-ajax id="ping"
      url="http://localhost:9494/ping?callback=handlePingResponse"
      handleAs="text"
      on-core-response="{{handlePingResponse}}"
      on-core-error="{{handlePingError}}">
    </core-ajax>
  </template>

  <script>
    /* global Polymer, _ */
    /*jshint newcap: false */
    Polymer("rise-storage", {
      /**
       * Fired when a response is received.
       *
       * @event rise-storage-response
       */

      /**
       * Fired when an error is received.
       *
       * @event rise-storage-error
       */

      /**
       * The ID of the Company.
       *
       * @attribute companyId
       * @type string
       * @default ""
       */
      companyId: "",

      /**
       * The folder name.
       *
       * @attribute folder
       * @type string
       * @default ""
       */
      folder: "",

      /**
       * The file name.
       *
       * @attribute fileName
       * @type string
       * @default ""
       */
      fileName: "",

      /**
       * Only return files that are of a particular file type.
       *
       * @attribute fileType
       * @type string
       * @default ""
       */
      fileType: "",

      /**
       * Only return files with a particular content type.
       *
       * @attribute contentType
       * @type string
       * @default ""
       */
      contentType: "",

      /**
       * The number of seconds before another request will be made.
       *
       * @attribute refresh
       * @type number
       * @default 0 (no refresh)
       */
      refresh: 0,

      /**
       * The order in which files are sorted.
       *
       * @attribute sort
       * @type string
       * @default ""
       */
      sort: "",

      /**
       * The direction in which files are sorted.
       *
       * @attribute sortDirection
       * @type string
       * @default ""
       */
      sortDirection: "",

      /**
       * Indicates whether or not the component is loading.
       *
       * @property isLoading
       * @type boolean
       * @default true
       */
      isLoading: true,

      /**
       * Indicates whether or not the Storage request is for a file.
       *
       * @property isFile
       * @type boolean
       * @default true
       */
      isFile: true,

      /**
       * The URL target of the Storage request.
       *
       * @property storageUrl
       * @type string
       * @default ""
       */
      storageUrl: "",

      /**
       * The URL target of the Cache request.
       *
       * @property cacheUrl
       * @type string
       * @default ""
       */
      cacheUrl: "",

      /**
       * The URL target of the Cache request.
       *
       * @property fileUrl
       * @type string
       * @default ""
       */
      fileUrl: "",

      /**
       * Stores item details from the previous request.
       *
       * @property items
       * @type object
       * @default []
       */
      items: [],

      /**
       * The base URL for Rise Cache.
       *
       * @property baseCacheUrl
       * @type string
       * @default "http://localhost:9494/cb="
       */
      baseCacheUrl: "http://localhost:9494/",

      /**
       * Whether or not Rise Cache is running.
       *
       * @property isCacheRunning
       * @type boolean
       * @default false
       */
      isCacheRunning: false,

      /**
       * Whether or not a response has been received from the ping request.
       *
       * @property pingReceived
       * @type boolean
       * @default false
       */
      pingReceived: false,

      /**
       * The number of files in a folder that have already been processed.
       *
       * @property numFiles
       * @type number
       * @default 0
       */
      numFiles: 0,

      /**
       * The total number of files in a folder.
       *
       * @property totalFiles
       * @type number
       * @default 0
       */
      totalFiles: 0,

      /**
       * The total number of files in a folder from the last request.
       *
       * @property totalFilesBefore
       * @type number
       * @default 0
       */
      totalFilesBefore: 0,

      /**
       * Stores details about a particular file in a folder.
       *
       * @property items
       * @type object
       * @default []
       */
      files: [],

      /**
       * Whether or not any of the files in a folder have changed.
       *
       * @property isChanged
       * @type boolean
       * @default false
       */
      isChanged: false,

      /************************************** INITIALIZATION **************************************/

      /**
       * Polymer has finished its initialization. This is the entry point.
       */
      ready: function() {
        this.images = ["image/jpeg", "image/png", "image/bmp", "image/svg+xml", "image/gif"];
        this.videos = ["video/mp4", "video/ogg", "video/webm"];
        this.contentTypes = this.contentType.split(" ");
      },

      /**
       * An instance of the element was inserted into the DOM.
       */
      attached: function() {
        this.$.ping.go();
      },

      /***************************************** STORAGE ******************************************/

      /**
       * Sets the URL that is used for making requests to Storage.
       */
      setStorageUrl: function() {
        var baseUrl = "https://www.googleapis.com/storage/v1/b/risemedialibrary-" + encodeURIComponent(this.companyId) + "/o",
          delimiter = "?delimiter=" + encodeURIComponent("/"),
          folder = "&prefix=" + encodeURIComponent(this.folder),
          fileName = encodeURIComponent(this.fileName),
          url = baseUrl;

        if (this.companyId) {
          if (this.folder) {
            // Append a "/" at end of folder if necessary.
            if (this.folder.slice(-1) !== "/") {
              folder += "/";
            }

            // Get a specific file in a specific folder.
            if (this.fileName) {
              url += delimiter + folder + fileName;
            }
            // Get all files in a specific folder.
            else {
              url += delimiter + folder;
            }
          }
          // Get a specific file in a bucket.
          else if (this.fileName) {
            url += "/" + fileName;
          }
          // Get all files in a bucket.
          else {
            url += delimiter;
          }

          this.storageUrl = url;
        }
      },

      /**
       * Fires when a response is received from the Storage request.
       */
      handleStorageResponse: function(e, resp) {
        if (resp && resp.response) {
          if (this.isLoading) {
            this.setIsFile(resp.response);
          }

          if (this.isFile) {
            if (this.isLoading) {
              this.setFileUrl(resp.response);
            }

            if (this.isCacheRunning) {
              this.getFileFromCache();
            }
            // Rise Cache is not running.
            else {
              this.handleStorageFile(resp.response);
            }
          }
          // Folder
          else {
            if (this.isCacheRunning) {
              this.getFilesFromCache(resp.response);
            }
            // Rise Cache is not running.
            else {
              this.handleStorageFolder(resp.response);
            }
          }
        }
        else {
          this.startTimer();
        }
      },

      /**
       * Fires when an error is received from the Storage request.
       */
      handleStorageError: function(e, resp) {
        console.error("Storage Error: " + resp.xhr.status + " " + resp.xhr.statusText);

        this.startTimer();
        this.fire("rise-storage-error", resp);
      },

      /**
       * Processes a Storage file.
       */
      handleStorageFile: function(resp) {
        var file = {},
          files = [],
          etag = null;

        // File in the root of the bucket.
        if (resp.selfLink !== undefined) {
          etag = resp.etag;
        }
        // File in a folder.
        else if ((resp.items !== undefined) && (resp.items.length > 0)) {
          etag = resp.items[0].etag;
        }

        file.url = this.fileUrl;

        if (this.isLoading) {
          this.items.push({
            "etag": etag
          });

          this.isLoading = false;
        }
        else {
          // File hasn't changed.
          if (this.items[0].etag === etag) {
            this.startTimer();

            return;
          }
          else {
            this.items[0].etag = etag;
            file.url += "&cb=" + new Date().getTime();
          }
        }

        files.push(file);
        this.fire("rise-storage-response", this.prepareResponse(files));
        this.startTimer();
      },

      /**
       * Processes multiple files in a Storage folder.
       */
      handleStorageFolder: function(resp) {
        var self = this,
          file = {},
          files = [],
          previousItem = null,
          suffix = "?alt=media",
          cb = "&cb=" + new Date().getTime();

        if (resp.items) {
          resp.items.forEach(function(item) {
            file = {};

            // Check that current item is not a folder.
            if (item.name && (item.name.slice(-1) !== "/")) {
              if (item.selfLink !== undefined) {
                if (!self.filterFiles(item.contentType)) {
                  return;
                }

                // Sorting
                if (self.sort) {
                  if (self.sort === "name") {
                    file.sortBy = item.name;
                  }
                  else if (self.sort === "date") {
                    file.sortBy = new Date(item.updated).getTime();
                  }
                }

                if (self.isLoading) {
                  // Construct URL.
                  if (self.isCacheRunning) {
                    file.url = self.baseCacheUrl + "?url=" + encodeURIComponent(item.selfLink + suffix);
                  }
                  else {
                    file.url = item.selfLink + suffix;
                  }

                  self.items.push({
                    "name": item.name,
                    "etag": item.etag,
                    "url": file.url
                  });
                }
                else {
                  // Construct URL.
                  if (self.isCacheRunning) {
                    file.url = self.baseCacheUrl + "cb=" + new Date().getTime() + "?url=" + encodeURIComponent(item.selfLink + suffix);
                  }
                  else {
                    file.url = item.selfLink + suffix + cb;
                  }

                  previousItem = _.find(self.items, function(obj) {
                    return obj.name === item.name;
                  });

                  // New file
                  if (previousItem === undefined) {
                    self.items.push({
                      "name": item.name,
                      "etag": item.etag,
                      "url": file.url
                    });
                  }
                  // Existing file
                  else {
                    if (item.etag === previousItem.etag) {
                      // Use the same URL as before in order to leverage browser caching.
                      // For Rise Cache, use a new URL every time. Since Rise Cache checks in
                      // with Storage every 15 minutes, a cache buster is needed to ensure that
                      // as soon as Rise Cache does get the updated file, the browser will pick it up.
                      if (!self.isCacheRunning) {
                        file.url = previousItem.url;
                      }
                    }
                    // File has changed.
                    else {
                      previousItem.etag = item.etag;
                      previousItem.url = file.url;
                    }
                  }
                }

                files.push(file);
              }
            }
          });

          this.isLoading = false;
          // Clean up files from this.items that are no longer in the folder.
          // Remove all this.items that are not in response.items. Use name field as the id.
          this.fire("rise-storage-response", this.prepareResponse(files));
          this.startTimer();
        }
      },

      /*************************************** RISE CACHE *****************************************/

      /**
       * Makes a request to Rise Cache to retrieve a file.
       */
      getFileFromCache: function() {
        if (this.isLoading) {
          this.cacheUrl = this.baseCacheUrl + "?url=" + this.fileUrl;
        }
        else {
          // Include a cache buster as this will be the URL that gets passed to the browser
          // if the file has changed.
          this.cacheUrl = this.baseCacheUrl + "cb=" + new Date().getTime() + "?url=" + this.fileUrl;
        }

        this.$.cache.go();
      },

      /**
       * Make requests to Rise Cache to retrieve all files in a folder.
       */
      getFilesFromCache: function(resp) {
        var self = this;

        if (resp.items) {
          this.numFiles = 0;
          this.files = [];
          this.isChanged = false;
          this.totalFilesBefore = this.totalFiles;

          // One item is the folder itself.
          this.totalFiles = resp.items.length - 1;

          resp.items.forEach(function(item) {
            // Check that current item is not a folder.
            if (item.name && (item.name.slice(-1) !== "/")) {
              if (!self.filterFiles(item.contentType)) {
                self.totalFiles--;
                return;
              }

              self.setFileUrl(item);
              self.cacheUrl = self.baseCacheUrl + "cb=" + new Date().getTime() + "?url=" + self.fileUrl;
              self.$.cache.go();
            }
          });
        }
      },

      /**
       * Fires when a response is received from the Rise Cache request.
       */
      handleCacheResponse: function(e, resp) {
        if (this.isFile) {
          this.handleCacheFile(resp);
        }
        else {
          this.handleCacheFolder(resp);
        }
      },

      /**
       * Process Rise Cache response for a Storage file.
       */
      handleCacheFile: function(resp) {
        var file = {},
          files = [],
          lastModified = "";

        if (resp && resp.xhr) {
          lastModified = resp.xhr.getResponseHeader("Last-Modified");
          file.url = this.cacheUrl;

          if (this.isLoading) {
            // Save Last Modified so it can be compared in subsequent requests.
            this.items.push({
              "lastModified": lastModified
            });

            if (lastModified === null) {
              console.log("File does not have a Last-Modified header: " + file.url);
            }

            this.isLoading = false;
          }
          else {
            // Rise Cache file hasn't changed.
            if (this.items[0].lastModified === lastModified) {
              this.startTimer();

              return;
            }
            else {
              this.items[0].lastModified = lastModified;
            }
          }

          files.push(file);
          this.fire("rise-storage-response", this.prepareResponse(files));
        }

        this.startTimer();
      },

      /**
       * Process Rise Cache response for a file in a Storage folder.
       */
      handleCacheFolder: function(resp) {
        var file = {},
          index = -1,
          url = "",
          searchString = "?url=",
          lastModified = "",
          previousItem = null;

        if (resp && resp.xhr) {
          file.url = resp.xhr.responseURL;
          lastModified = resp.xhr.getResponseHeader("Last-Modified");

          // Extract the URL from the query string parameter.
          if (file.url) {
            index = file.url.indexOf(searchString);

            if (index !== -1) {
              url = file.url.substring(index + searchString.length);
            }
          }

          if (this.isLoading) {
            // Save file details so they can be compared in subsequent requests.
            this.items.push({
              "lastModified": lastModified,
              "fullUrl": file.url,
              "url": url
            });

            if (lastModified === null) {
              console.log("File does not have a Last-Modified header: " + file.url);
            }
          }
          else {
            previousItem = _.find(this.items, function(obj) {
              return obj.url === url;
            });

            // New file
            if (previousItem === undefined) {
              this.items.push({
                "lastModified": lastModified,
                "fullUrl": file.url,
                "url": url
              });
            }
            // Existing file
            else {
              if (lastModified === previousItem.lastModified) {
                // Use the same URL as before in order to leverage browser caching.
                file.url = previousItem.fullUrl;
              }
              // File has changed.
              else {
                previousItem.lastModified = lastModified;
                previousItem.fullUrl = file.url;
                this.isChanged = true;
              }
            }
          }

          this.files.push(file);
        }

        this.numFiles++;

        if (this.numFiles === this.totalFiles) {
          // If number of files in the folder has changed, then file(s) have either been added
          // or removed.
          if (this.totalFiles !== this.totalFilesBefore) {
            this.isChanged = true;
          }

          if (this.isLoading || this.isChanged) {
            this.fire("rise-storage-response", this.prepareResponse(this.files));
          }

          this.startTimer();
          this.isLoading = false;
        }
      },

      /**
       * Fires when an error is received from the Rise Cache request.
       */
      handleCacheError: function(e, resp) {
        console.error("Rise Cache Error: " + resp.xhr.status + " " + resp.xhr.statusText);

        this.startTimer();
        this.fire("rise-storage-error", resp);
      },

      /**
       * Fires when a response is received from the ping request.
       */
      handlePingResponse: function(e, resp) {
        if (resp.response === "") {
          this.isCacheRunning = false;
        }
        else {
          this.isCacheRunning = true;
        }

        this.pingReceived = true;
        this.go();
      },

      /**
       * Fires when an error is received from the ping request.
       */
      handlePingError: function(e, resp) {
        console.error("Ping Error: " + resp.xhr.status + " " + resp.xhr.statusText);

        this.isCacheRunning = false;
        this.pingReceived = true;
        this.go();
      },

      /****************************************** COMMON ******************************************/

      /**
       * Performs a request to the Storage API.
       */
      go: function() {
        if (this.pingReceived) {
          this.setStorageUrl();
          this.$.storage.go();
        }
      },

      /**
       * Handles a refresh.
       */
      startTimer: function() {
        this.refresh = parseInt(this.refresh, 10);

        if (!isNaN(this.refresh) && this.refresh !== 0) {
          this.refresh = (this.refresh < 5) ? 5 : this.refresh;

          this.job("refresh", function() {
            if (this.isFile) {
              if (this.isCacheRunning) {
                this.getFileFromCache();
              }
              else {
                this.$.storage.go();
              }
            }
            // Folder
            else {
              this.$.storage.go();
            }
          }, this.refresh * 60000);
        }
      },

      /**
       * Checks if the request is for a file.
       */
      setIsFile: function(response) {
        // File in the root of the bucket.
        if (response.selfLink !== undefined) {
          this.isFile = true;
        }
        // File in a folder.
        else if ((response.items !== undefined) && (response.items.length > 0)) {
          if (response.items.length === 1) {
            this.isFile = true;
          }
          else {
            this.isFile = false;
          }
        }
      },

      /**
       * Sets the URL to the Storage file.
       */
      setFileUrl: function(response) {
        var url = "",
          bucket = "",
          filePath = "",
          startIndex = -1,
          endIndex = -1,
          suffix = "?alt=media";

        // File in the root of the bucket.
        if (response.selfLink) {
          url = response.selfLink;
        }
        // File in a folder.
        else if (response.items) {
          url = response.items[0].selfLink;
        }

        if (this.isCacheRunning) {
          // URLs starting with www.googleapis.com do not return a Last Modified HTTP header.
          // Use a storage.googleapis.com URL instead, which does return it.
          startIndex = url.indexOf("risemedialibrary");
          endIndex = url.indexOf("/o/");
          bucket = url.substring(startIndex, endIndex);
          filePath = url.substring(endIndex + ("/o/".length));
          this.fileUrl = encodeURIComponent("https://storage.googleapis.com/" + bucket + "/" + filePath);
        }
        else {
          this.fileUrl = url + suffix;
        }
      },

      /**
       * Performs any necessary filtering.
       */
      filterFiles: function(contentType) {
        if (this.fileType) {
          return this.filterByFileType(contentType);
        }
        else if (this.contentType) {
          return this.filterByContentType(contentType);
        }

        return true;
      },

      /**
       * Filters an item by content type.
       */
      filterByContentType: function(contentType) {
        for (var i = 0; i < this.contentTypes.length; i++) {
          if (contentType === this.contentTypes[i]) {
            return true;
          }
        }

        return false;
      },

      /**
       * Filters an item by file type.
       */
      filterByFileType: function(contentType) {
        var i;

        if (this.fileType === "image") {
          for (i = 0; i < this.images.length; i++) {
            if (contentType === this.images[i]) {
              return true;
            }
          }
        }
        else if (this.fileType === "video") {
          for (i = 0; i < this.videos.length; i++) {
            if (contentType === this.videos[i]) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Sorts all files.
       */
      sortFiles: function(files) {
        if (this.sort === "name" || this.sort === "date") {
          files = _.sortBy(files, function(file) {
            return file.sortBy;
          });
        }
        else if (this.sort === "random") {
          return _.shuffle(files);
        }

        // Direction
        if (this.sortDirection) {
          if (this.sortDirection === "asc") {
            return files;
          }
          else if (this.sortDirection === "desc") {
            return files.reverse();
          }
        }

        return files;
      },

      /**
       * Prepares the response object.
       */
      prepareResponse: function(files) {
        var self = this,
          response = {};

        response.files = [];

        if (this.sort && files.length > 0) {
          files = this.sortFiles(files);
        }

        files.forEach(function(file) {
          if (self.sort) {
            delete file.sortBy;
          }

          response.files.push(file);
        });

        return response;
      }
    });
  </script>
</polymer-element>
